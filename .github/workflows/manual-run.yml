name: Service Run

run-name: "${{ github.event.inputs.run-name || (github.event_name == 'workflow_dispatch' && 'Manual Service Run') || (github.event_name == 'push' && 'CI Service Run') || 'Scheduled Service Run' }}"

# Run services for a specified duration
# - Manual: workflow_dispatch with custom parameters
# - Automatic: on push and daily schedule (uses same defaults as manual)
on:
  workflow_dispatch:
    inputs:
      run-name:
        description: 'Custom name for this run (e.g., "E2E Tests - Login Flow")'
        required: false
        default: 'Manual Service Run'
        type: string
      duration:
        description: 'Duration to keep services running (minutes)'
        required: true
        default: '30'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '300'
      version:
        description: 'Version for Docker images, Python CLI (rediacc), and Node.js CLI (rdc)'
        required: false
        default: 'latest'
        type: string
      enable-vms:
        description: 'Enable VM provisioning for infrastructure testing'
        required: false
        default: true
        type: boolean
      vm-provider:
        description: 'VM infrastructure provider (only if VMs enabled)'
        required: false
        default: 'kvm'
        type: choice
        options:
          - 'kvm'
          - 'linode'
          - 'vultr'
      vm-configuration:
        description: 'VM cluster configuration (only if VMs enabled)'
        required: false
        default: 'Standard'
        type: choice
        options:
          - 'Minimal'
          - 'Basic'
          - 'Standard'
          - 'Full'
      vm-os-image:
        description: 'VM OS image (only if VMs enabled)'
        required: false
        default: 'rediacc-ubuntu-24.04'
        type: choice
        options:
          - 'ubuntu-24.04'
          - 'debian-12'
          - 'debian-11'
          - 'fedora-43'
          - 'fedora-42'
          - 'oracle-linux-9'
          - 'oracle-linux-8'
          - 'opensuse-15.6'
          - 'opensuse-15.5'
          - 'rocky-9'
          - 'centos-stream-10'
          - 'rediacc-ubuntu-24.04'
          - 'rediacc-debian-12'
          - 'rediacc-debian-11'
          - 'rediacc-fedora-43'
          - 'rediacc-oracle-linux-9'
          - 'rediacc-opensuse-15.5'
          - 'rediacc-centos-stream-10'
      enable-debug:
        description: 'Enable tmate SSH debugging session'
        required: false
        default: false
        type: boolean
      skip-machine-registration:
        description: 'Skip automatic machine registration'
        required: false
        default: false
        type: boolean
      ci-mode:
        description: 'Enable CI/TEST mode (bypasses email and captcha validation)'
        required: false
        default: true
        type: boolean
      desktop-environment:
        description: 'Desktop environment for browser access (via noVNC)'
        required: false
        default: 'xfce'
        type: choice
        options:
          - 'none'
          - 'xfce'
          - 'gnome'
          - 'mate'
      desktop-resolution:
        description: 'Desktop screen resolution (only if desktop enabled)'
        required: false
        default: '1600x900'
        type: choice
        options:
          - '1024x768'
          - '1280x720'
          - '1366x768'
          - '1600x900'
          - '1920x1080'
          - '2560x1440'

  push:
    branches:
      - main

  schedule:
    # Run once daily at 00:00 UTC
    - cron: '0 0 * * *'

jobs:
  run-services:
    name: Run Rediacc Elite Services
    runs-on: ubuntu-latest
    timeout-minutes: 420  # 7 hours max (including VM provisioning time)

    # Consolidated defaults - these match the workflow_dispatch input defaults
    env:
      DEFAULT_DURATION: '30'
      DEFAULT_VM_CONFIGURATION: 'Standard'
      DEFAULT_VM_PROVIDER: 'kvm'
      DEFAULT_VM_OS_IMAGE: 'rediacc-ubuntu-24.04'
      DEFAULT_ENABLE_VMS: 'true'
      DEFAULT_DESKTOP_ENVIRONMENT: 'xfce'
      DEFAULT_DESKTOP_RESOLUTION: '1600x900'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate and Set Version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: ./action/ci-validate-version.sh "${{ github.event.inputs.version || 'latest' }}"

      - name: Pre-pull Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          TAG: ${{ env.TAG }}
          ENABLE_DESKTOP: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'true' || 'false' }}
        run: ./action/ci-pull-images.sh

      - name: Create Debug Session
        if: github.event.inputs.enable-debug == 'true'
        id: tmate
        uses: rediacc/action-tmate@v1
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Start Rediacc Elite Services
        id: services
        uses: ./action
        with:
          keep-alive: true  # Don't auto-cleanup, we'll handle it manually
          ci-mode: ${{ github.event.inputs.ci-mode != 'false' && 'true' || 'false' }}
        env:
          TAG: ${{ env.TAG }}
          # Machine registration will happen later after VMs are provisioned
          SKIP_MACHINE_REGISTRATION: 'true'
          # Enable desktop gateway if requested
          ENABLE_DESKTOP: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'true' || 'false' }}

      - name: Setup Desktop Environment
        if: (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none'
        id: desktop
        env:
          DESKTOP_ENVIRONMENT: ${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}
          DESKTOP_RESOLUTION: ${{ github.event.inputs.desktop-resolution || env.DEFAULT_DESKTOP_RESOLUTION }}
        run: |
          chmod +x action/ci-desktop.sh
          action/ci-desktop.sh

      - name: Extract SSH Keys from Middleware
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        env:
          TAG: ${{ env.TAG }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”‘ Extracting SSH Keys from Middleware"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Wait for middleware to be fully ready
          echo "Waiting for middleware to be ready..."
          timeout 60 bash -c 'until ./go health; do sleep 2; done'
          echo "âœ“ Middleware is healthy"

          # Install rediacc CLI (try local /pypi/ first, fallback to public PyPI)
          TAG_VERSION="${TAG:-latest}"
          LOCAL_PYPI="http://localhost/pypi/"
          LOCAL_NPM="http://localhost/npm/"

          echo "Installing rediacc CLI (Python)..."
          if [ "$TAG_VERSION" = "latest" ]; then
            # Try local first, fallback to PyPI
            if pip install --quiet --find-links "$LOCAL_PYPI" --trusted-host localhost rediacc 2>/dev/null; then
              echo "âœ“ Installed rediacc from local /pypi/"
            else
              echo "Local package not found, installing from PyPI..."
              pip install --quiet rediacc
              echo "âœ“ Installed rediacc from PyPI"
            fi
          else
            # Try local with version, fallback to PyPI
            if pip install --quiet --find-links "$LOCAL_PYPI" --trusted-host localhost "rediacc==$TAG_VERSION" 2>/dev/null; then
              echo "âœ“ Installed rediacc $TAG_VERSION from local /pypi/"
            elif pip install --quiet "rediacc==$TAG_VERSION" 2>/dev/null; then
              echo "âœ“ Installed rediacc $TAG_VERSION from PyPI"
            else
              echo "Version $TAG_VERSION not found, installing latest from PyPI..."
              pip install --quiet rediacc
              echo "âœ“ Installed rediacc (latest) from PyPI"
            fi
          fi

          # Install rdc CLI (Node.js) - try local /npm/ first
          echo "Installing rdc CLI (Node.js)..."
          if [ "$TAG_VERSION" = "latest" ]; then
            # Try local first - find the latest version tarball
            LOCAL_TGZ=$(curl -s "$LOCAL_NPM" 2>/dev/null | grep -oP 'rediacc-cli-[\d.]+\.tgz' | sort -V | tail -1)
            if [ -n "$LOCAL_TGZ" ] && npm install -g "${LOCAL_NPM}${LOCAL_TGZ}" 2>/dev/null; then
              echo "âœ“ Installed rdc from local /npm/"
            else
              echo "Local npm package not found, skipping rdc installation"
            fi
          else
            # Try local with specific version
            LOCAL_TGZ="rediacc-cli-${TAG_VERSION}.tgz"
            if curl -sf "${LOCAL_NPM}${LOCAL_TGZ}" -o /dev/null 2>/dev/null && npm install -g "${LOCAL_NPM}${LOCAL_TGZ}" 2>/dev/null; then
              echo "âœ“ Installed rdc $TAG_VERSION from local /npm/"
            else
              echo "Version $TAG_VERSION not found in local /npm/, skipping rdc installation"
            fi
          fi

          # Verify installations
          echo ""
          echo "CLI versions installed:"
          rediacc --version || echo "  rediacc: not installed"
          rdc --version 2>/dev/null || echo "  rdc: not installed"
          echo ""

          # Register rediacc protocol handler
          rediacc protocol register

          # Source environment for credentials
          source action/ci-env.sh

          # Set API URL explicitly (services run on localhost)
          export SYSTEM_API_URL="http://localhost/api"

          # Login to middleware
          echo "Logging in to middleware..."
          echo "API URL: $SYSTEM_API_URL"
          rediacc auth login \
            --endpoint "$SYSTEM_API_URL" \
            --email "$SYSTEM_ADMIN_EMAIL" \
            --password "$SYSTEM_ADMIN_PASSWORD"

          # Fetch team vault
          echo "Fetching team vault..."
          TEAM_VAULT=$(rediacc GetCompanyTeams --output json | \
            jq -r --arg team "$SYSTEM_DEFAULT_TEAM_NAME" \
            '.data.result[] | select(.teamName == $team or .TeamName == $team) | .vaultContent')

          # Extract and decode SSH keys
          echo "Extracting SSH keys from vault..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          echo "$TEAM_VAULT" | jq -r '.SSH_PRIVATE_KEY' | base64 -d > ~/.ssh/id_rsa
          echo "$TEAM_VAULT" | jq -r '.SSH_PUBLIC_KEY' | base64 -d > ~/.ssh/id_rsa.pub

          chmod 600 ~/.ssh/id_rsa
          chmod 644 ~/.ssh/id_rsa.pub

          echo "âœ“ SSH keys extracted and written to ~/.ssh/"
          echo "Key fingerprint:"
          ssh-keygen -lf ~/.ssh/id_rsa.pub

          # Logout
          rediacc auth logout

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Provision VMs
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        id: vms
        uses: rediacc/ops/.github/actions/setup-vms@main
        with:
          provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}
          configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}
          duration: ${{ github.event.inputs.duration || env.DEFAULT_DURATION }}
          api-token: ${{ github.event.inputs.vm-provider == 'linode' && secrets.LINODE_API_TOKEN || github.event.inputs.vm-provider == 'vultr' && secrets.VULTR_API_TOKEN || '' }}
        env:
          VM_OS_IMAGE: ${{ github.event.inputs.vm-os-image || env.DEFAULT_VM_OS_IMAGE }}
          TAG: ${{ env.TAG }}
          # DOCKER_REGISTRY is managed by setup-vms action based on provider
          # KVM uses local registry (192.168.111.1:5000), cloud providers use ghcr.io
          DOCKER_BRIDGE_IMAGE: ghcr.io/rediacc/elite/bridge:${{ env.TAG }}
          DOCKER_BRIDGE_NETWORK_MODE: host
          DOCKER_BRIDGE_API_URL: http://localhost
          SYSTEM_API_URL: http://localhost/api
          SKIP_MACHINE_REGISTRATION: 'true'
          CI_MODE: ${{ github.event.inputs.ci-mode != 'false' && 'true' || 'false' }}

      - name: Capture VM Provisioning Logs on Failure
        if: failure() && (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Capturing VM Provisioning Logs (Failure Debug)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # OPS_REPO_PATH is set by setup-vms action
          OPS_PATH="${OPS_REPO_PATH:-/home/runner/work/_actions/rediacc/ops/main}"
          cd "$OPS_PATH" || exit 0

          export SDK_HOME="$(pwd)"
          source scripts/init.sh 2>/dev/null || true

          # Create staging directory for logs
          mkdir -p staging

          # Bridge VM IP (from previous provisioning attempt)
          BRIDGE_IP="192.168.111.1"

          echo ""
          echo "ğŸ” Attempting to retrieve logs from Bridge VM ($BRIDGE_IP)..."
          echo ""

          # Try to copy logs from bridge VM
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes runner@$BRIDGE_IP "test -f /tmp/rediacc_log.txt" 2>/dev/null; then
            echo "ğŸ“„ Bridge Log File (/tmp/rediacc_log.txt):"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "cat /tmp/rediacc_log.txt" 2>/dev/null | tee staging/rediacc_log.txt || true
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo ""
          else
            echo "âš ï¸  Could not access bridge log file"
          fi

          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes runner@$BRIDGE_IP "test -f /tmp/rediacc_err.txt" 2>/dev/null; then
            echo "ğŸ“„ Bridge Error File (/tmp/rediacc_err.txt):"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "cat /tmp/rediacc_err.txt" 2>/dev/null | tee staging/rediacc_err.txt || true
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo ""
          else
            echo "âš ï¸  Could not access bridge error file"
          fi

          # Also try to get docker logs from the bridge VM
          echo "ğŸ“„ Recent Docker Container Logs on Bridge:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "docker ps -a --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}' 2>/dev/null" || true
          echo ""
          ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "docker logs \$(docker ps -aq -n 1) 2>&1 | tail -100" 2>/dev/null | tee staging/docker_last_container.txt || true
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

          # Check if local staging files exist from orch_copy_back_files
          if [ -f "$SDK_HOME/staging/rediacc_log.txt" ]; then
            echo "ğŸ“„ Local Staging Log (already copied):"
            cat "$SDK_HOME/staging/rediacc_log.txt"
          fi

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Upload VM Provisioning Logs Artifact
        if: always() && (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: vm-provisioning-logs-${{ github.run_id }}
          path: |
            /home/runner/work/_actions/rediacc/ops/main/staging/
            staging/
          if-no-files-found: ignore
          retention-days: 7

      - name: Display VM Information
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ–¥ï¸  VM Infrastructure Provisioned"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ VM CONFIGURATION:"
          echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
          echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
          echo "   â€¢ OS Image: ${{ github.event.inputs.vm-os-image || env.DEFAULT_VM_OS_IMAGE }}"
          echo "   â€¢ Status: ${{ steps.vms.outputs.status }}"
          echo ""
          echo "ğŸŒ VM ACCESS:"
          echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
          echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
          echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
          echo ""
          echo "ğŸ”‘ SSH KEYS: Using keys from middleware (single source of truth)"
          echo "âš™ï¸  VMs are now accessible with middleware's SSH keys"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Register Worker Machines
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true' && github.event.inputs.skip-machine-registration != 'true'
        run: |
          source action/ci-env.sh

          # Set environment variables for registration
          export VM_DEPLOYMENT="true"
          export VM_BRIDGE_IP="${{ steps.vms.outputs.bridge-ip }}"
          export VM_WORKER_IPS="${{ steps.vms.outputs.worker-ips }}"
          export VM_PROVIDER="${{ github.event.inputs.vm-provider || 'kvm' }}"

          echo "Registering worker machines with middleware..."
          action/ci-register-workers.sh

      - name: Display Service Information
        run: |
          # Set duration: use input if available, otherwise use consolidated default
          DURATION="${{ github.event.inputs.duration || env.DEFAULT_DURATION }}"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TRIGGER_TYPE="Manual"
          elif [ "${{ github.event_name }}" == "push" ]; then
            TRIGGER_TYPE="Automatic (Push)"
          else
            TRIGGER_TYPE="Automatic (Schedule)"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Rediacc Elite Services are now running!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "â±ï¸  SELECTED DURATION: ${DURATION} minutes ($TRIGGER_TYPE)"
          echo ""
          
          # Display deployment-specific information
          if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then
            echo "ğŸ–¥ï¸  DEPLOYMENT: VM Infrastructure"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo "   â€¢ VM Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ“ VM Service URLs:"
            echo "   â€¢ API URL: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
            echo ""
            echo "ğŸ”— SSH Access to Bridge VM:"
            echo "   ssh -i ~/.ssh/vm_key ubuntu@${{ steps.vms.outputs.bridge-ip }}"
          else
            echo "ğŸ³ DEPLOYMENT: GitHub Runner (Docker)"
            echo ""
            echo "ğŸ“ Local Service URLs:"
            echo "   â€¢ API URL: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          fi
          
          echo ""
          echo "â³ Setting up public access via Cloudflare Tunnel..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Save duration for later steps
          echo "$DURATION" > /tmp/duration.txt

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          # Elite services always run on localhost (runner or local machine)
          # VMs are separate infrastructure resources for testing, not service deployment targets
          # When desktop is enabled, route through Caddy gateway on port 8080
          url: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'http://localhost:8080' || 'http://localhost' }}
          timeout: 30

      - name: Initial Service Status
        run: |
          echo ""
          echo "ğŸ“Š Initial Service Status:"
          ./go status
          echo ""
          echo "âœ… Health Check:"
          ./go health

      - name: Export Deployment Information
        run: |
          # Create comprehensive deployment info JSON
          cat > deployment-info.json << EOF
          {
            "metadata": {
              "run_id": "${{ github.run_id }}",
              "duration_minutes": ${{ github.event.inputs.duration || env.DEFAULT_DURATION }},
              "version": "${{ env.TAG }}",
              "triggered_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "workflow_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            },
            "access": {
              "tunnel_url": "${{ steps.tunnel.outputs.tunnel-url }}",
              "api_url": "${{ steps.services.outputs.api-url }}",
              "web_url": "http://localhost",
              "desktop_url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"${{ steps.tunnel.outputs.tunnel-url }}/desktop\""; else echo "null"; fi)
            },
            "database": {
              "connection_string": "Server=sql,1433;Database=RediaccMiddleware;User Id=rediacc;TrustServerCertificate=True"
            },
            "vms": {
              "enabled": ${{ (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true' }},
              "provider": "${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}",
              "configuration": "${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}",
              "bridge_ip": "${{ steps.vms.outputs.bridge-ip || null }}",
              "worker_ips": $(echo '${{ steps.vms.outputs.worker-ips }}' | jq -R 'if . == "" then null else split(",") end'),
              "registry_url": "${{ steps.vms.outputs.registry-url || null }}",
              "machine_user": "${{ steps.vms.outputs.machine-user || null }}",
              "machine_password": "${{ steps.vms.outputs.machine-password || null }}",
              "ssh_access": {
                "bridge": $(if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then echo "\"ssh ${{ steps.vms.outputs.machine-user }}@${{ steps.vms.outputs.bridge-ip }}\""; else echo "null"; fi),
                "workers": $(if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then echo '${{ steps.vms.outputs.worker-ips }}' | jq -R --arg user "${{ steps.vms.outputs.machine-user }}" 'if . == "" then null else split(",") | map("ssh " + $user + "@" + .) end'; else echo "null"; fi)
              }
            },
            "debug": {
              "enabled": ${{ github.event.inputs.enable-debug == 'true' }},
              "ssh_connection": "${{ steps.tmate.outputs.ssh-connection || null }}",
              "web_url": "${{ steps.tmate.outputs.web-url || null }}",
              "ssh_ro_connection": "${{ steps.tmate.outputs.ssh-ro-connection || null }}",
              "web_ro_url": "${{ steps.tmate.outputs.web-ro-url || null }}"
            },
            "desktop": {
              "enabled": ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' }},
              "environment": "${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}",
              "url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"${{ steps.tunnel.outputs.tunnel-url }}/desktop\""; else echo "null"; fi),
              "local_url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"http://localhost:6080/vnc.html\""; else echo "null"; fi)
            }
          }
          EOF

          # Beautify JSON with 2-space indentation
          jq --indent 2 '.' deployment-info.json > deployment-info.json.tmp && mv deployment-info.json.tmp deployment-info.json

          # Display for logs
          echo "ğŸ“‹ Deployment Information:"
          cat deployment-info.json

      - name: Upload Deployment Info Artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info-${{ github.run_id }}
          path: deployment-info.json
          retention-days: 1

      - name: Display Access Information and Keep Services Alive
        run: |
          # Display Access Information
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ ACCESS INFORMATION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸŒ WEB ACCESS:"
          echo "   â€¢ Cloudflare Tunnel: ${{ steps.tunnel.outputs.tunnel-url }}"
          DESKTOP_ENV="${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}"
          if [ "$DESKTOP_ENV" != "none" ]; then
            echo "   â€¢ Desktop (noVNC): ${{ steps.tunnel.outputs.tunnel-url }}/desktop"
            echo "   â€¢ Environment: $DESKTOP_ENV"
            echo "   â€¢ Resolution: ${{ github.event.inputs.desktop-resolution || env.DEFAULT_DESKTOP_RESOLUTION }}"
          fi
          echo ""

          # Display VM infrastructure details if enabled
          if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then
            echo "ğŸ–¥ï¸  VM INFRASTRUCTURE:"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo ""
            echo "ğŸ“ VM SERVICE URLS:"
            echo "   â€¢ API: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ” VM CREDENTIALS:"
            echo "   â€¢ Username: ${{ steps.vms.outputs.machine-user }}"
            echo "   â€¢ Password: ${{ steps.vms.outputs.machine-password }}"
            echo ""
            echo "ğŸ”‘ SSH ACCESS TO VMS:"
            echo "   â€¢ Bridge:  ssh ${{ steps.vms.outputs.machine-user }}@${{ steps.vms.outputs.bridge-ip }}"

            # Parse and display worker IPs
            IFS=',' read -ra WORKER_ARRAY <<< "${{ steps.vms.outputs.worker-ips }}"
            for i in "${!WORKER_ARRAY[@]}"; do
              echo "   â€¢ Worker $((i+1)): ssh ${{ steps.vms.outputs.machine-user }}@${WORKER_ARRAY[$i]}"
            done
            echo ""
          else
            echo "ğŸ³ LOCAL SERVICES:"
            echo "   â€¢ API: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
          fi

          echo "ğŸ—„ï¸  DATABASE:"
          echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          echo ""

          # Display debug access if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            echo "ğŸ”§ DEBUG ACCESS (Interactive Terminal):"
            echo "   â€¢ SSH:         ${{ steps.tmate.outputs.ssh-connection }}"
            echo "   â€¢ Web:         ${{ steps.tmate.outputs.web-url }}"
            echo "   â€¢ SSH (RO):    ${{ steps.tmate.outputs.ssh-ro-connection }}"
            echo "   â€¢ Web (RO):    ${{ steps.tmate.outputs.web-ro-url }}"
            echo ""
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Keep Services Alive
          DURATION_MIN=$(cat /tmp/duration.txt)
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          echo "â³ Keeping services alive for ${DURATION_MIN} minutes..."
          echo "   Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "   End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            # Run health check quietly
            if ./go health > /dev/null 2>&1; then
              echo "â±ï¸  ${REMAINING} minutes remaining - services healthy"
            else
              echo "â±ï¸  ${REMAINING} minutes remaining - âš ï¸  health check failed"
              echo ""
              echo "ğŸ“‹ Container Status:"
              ./go status
              echo ""
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â° Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "ğŸ“Š Final Service Status:"
          ./go status || true
          echo ""
          echo "ğŸ“‹ Recent Logs (last 50 lines):"
          ./go logs --tail=50 || true

      - name: Cleanup Services
        if: always()
        run: |
          echo ""
          echo "ğŸ§¹ Cleaning up services..."

          # Stop tmate session if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ]; then
              if ps -p $TMATE_PID > /dev/null 2>&1; then
                echo "ğŸ–¥ï¸  Stopping tmate session (PID: $TMATE_PID)..."
                kill $TMATE_PID || true
              fi
            fi
          fi

          # Stop cloudflared tunnel
          TUNNEL_PID="${{ steps.tunnel.outputs.tunnel-pid }}"
          if [ -n "$TUNNEL_PID" ]; then
            if ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "ğŸŒ Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
              kill $TUNNEL_PID || true
            fi
          fi

          # Cleanup elite services
          ./action/ci-cleanup.sh
          echo "âœ… Cleanup completed"

      - name: Summary
        if: always()
        run: |
          # Get duration from input or use consolidated default
          DURATION_MIN="${{ github.event.inputs.duration || env.DEFAULT_DURATION }}"

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Run Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "   â€¢ Requested duration: ${DURATION_MIN} minutes"
          echo "   â€¢ Workflow status: ${{ job.status }}"
          echo "   â€¢ Completion time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  cleanup-vms:
    name: Cleanup VM Infrastructure
    needs: [run-services]
    if: always() && (github.event.inputs.enable-vms == 'true' || (github.event.inputs.enable-vms == '' && true))
    runs-on: ubuntu-latest

    # Need to redefine defaults here since job-level env from run-services isn't accessible
    env:
      DEFAULT_VM_PROVIDER: 'kvm'

    steps:
      - name: Checkout SDK Repository
        uses: actions/checkout@v4
        with:
          repository: rediacc/ops
          ref: main

      - name: Cleanup VMs
        uses: ./.github/actions/cleanup-vms
        with:
          provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}
