name: Manual Service Run

# Run services for a specified duration
# - Manual: workflow_dispatch with custom duration
# - Automatic: on push and daily schedule (5 minutes)
on:
  workflow_dispatch:
    inputs:
      duration:
        description: 'Duration to keep services running (minutes)'
        required: true
        default: '30'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '300'
      version:
        description: 'Version for both Docker images and CLI pip package (e.g., latest, 0.1.67, 0.2.1)'
        required: false
        default: 'latest'
        type: string
      enable-vms:
        description: 'Enable VM provisioning for infrastructure testing'
        required: false
        default: false
        type: boolean
      vm-provider:
        description: 'VM infrastructure provider (only if VMs enabled)'
        required: false
        default: 'kvm'
        type: choice
        options:
          - 'kvm'
          - 'linode'
          - 'vultr'
      vm-configuration:
        description: 'VM cluster configuration (only if VMs enabled)'
        required: false
        default: 'Basic'
        type: choice
        options:
          - 'Minimal'
          - 'Basic'
          - 'Standard'
          - 'Full'
      vm-os-image:
        description: 'VM OS image (only if VMs enabled)'
        required: false
        default: 'rediacc-ubuntu-24.04'
        type: choice
        options:
          - 'ubuntu-24.04'
          - 'debian-12'
          - 'debian-11'
          - 'fedora-43'
          - 'fedora-42'
          - 'oracle-linux-9'
          - 'oracle-linux-8'
          - 'opensuse-15.6'
          - 'opensuse-15.5'
          - 'rocky-9'
          - 'centos-stream-10'
          - 'rediacc-ubuntu-24.04'
          - 'rediacc-debian-12'
          - 'rediacc-debian-11'
          - 'rediacc-fedora-43'
          - 'rediacc-oracle-linux-9'
          - 'rediacc-opensuse-15.5'
          - 'rediacc-centos-stream-10'
      enable-debug:
        description: 'Enable tmate SSH debugging session'
        required: false
        default: false
        type: boolean

  push:
    branches:
      - main

  schedule:
    # Run once daily at 00:00 UTC
    - cron: '0 0 * * *'

jobs:
  run-services:
    name: Run Rediacc Elite Services
    runs-on: ubuntu-latest
    timeout-minutes: 420  # 7 hours max (including VM provisioning time)

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate and Set Version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: ./action/ci-validate-version.sh "${{ github.event.inputs.version || 'latest' }}"

      - name: Pre-pull Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          TAG: ${{ env.TAG }}
        run: ./action/ci-pull-images.sh

      - name: Provision VMs
        if: github.event.inputs.enable-vms == 'true'
        id: vms
        uses: rediacc/ops/.github/actions/setup-vms@main
        with:
          provider: ${{ github.event.inputs.vm-provider || 'kvm' }}
          configuration: ${{ github.event.inputs.vm-configuration || 'Basic' }}
          duration: ${{ github.event.inputs.duration }}
          api-token: ${{ github.event.inputs.vm-provider == 'linode' && secrets.LINODE_API_TOKEN || github.event.inputs.vm-provider == 'vultr' && secrets.VULTR_API_TOKEN || '' }}
        env:
          VM_OS_IMAGE: ${{ github.event.inputs.vm-os-image || 'rediacc-ubuntu-24.04' }}

      - name: Display VM Information
        if: github.event.inputs.enable-vms == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ–¥ï¸  VM Infrastructure Provisioned"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ VM CONFIGURATION:"
          echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || 'kvm' }}"
          echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || 'Basic' }}"
          echo "   â€¢ OS Image: ${{ github.event.inputs.vm-os-image || 'rediacc-ubuntu-24.04' }}"
          echo "   â€¢ Status: ${{ steps.vms.outputs.status }}"
          echo ""
          echo "ğŸŒ VM ACCESS:"
          echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
          echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
          echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
          echo ""
          echo "âš™ï¸  Elite services will be deployed to VM infrastructure"
          echo "âš™ï¸  SSH configured by SDK for seamless VM access"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Create Debug Session
        if: github.event.inputs.enable-debug == 'true'
        id: tmate
        uses: rediacc/action-tmate@v1
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Configure Deployment Environment
        run: |
          if [ "${{ github.event.inputs.enable-vms }}" == "true" ]; then
            # VM deployment configuration
            echo "DEPLOYMENT_TARGET=vm" >> $GITHUB_ENV
            echo "DEPLOYMENT_HOST=${{ steps.vms.outputs.bridge-ip }}" >> $GITHUB_ENV
            echo "DEPLOYMENT_REGISTRY=${{ steps.vms.outputs.registry-url }}" >> $GITHUB_ENV
            echo "VM_BRIDGE_IP=${{ steps.vms.outputs.bridge-ip }}" >> $GITHUB_ENV
            echo "VM_WORKER_IPS=${{ steps.vms.outputs.worker-ips }}" >> $GITHUB_ENV
            
            # Override registry for VM deployment
            echo "DOCKER_REGISTRY=${{ steps.vms.outputs.registry-url }}" >> $GITHUB_ENV
            
            echo "ğŸ–¥ï¸  Deployment target: VM Infrastructure"
            echo "   Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   Registry: ${{ steps.vms.outputs.registry-url }}"
          else
            # GitHub runner deployment configuration (default)
            echo "DEPLOYMENT_TARGET=runner" >> $GITHUB_ENV
            echo "DEPLOYMENT_HOST=localhost" >> $GITHUB_ENV
            echo "DEPLOYMENT_REGISTRY=${DOCKER_REGISTRY}" >> $GITHUB_ENV
            
            echo "ğŸ³ Deployment target: GitHub Runner (Docker)"
          fi

      - name: Start Rediacc Elite Services
        id: services
        uses: ./action
        with:
          keep-alive: true  # Don't auto-cleanup, we'll handle it manually
        env:
          TAG: ${{ env.TAG }}
          # Pass VM configuration to action if VMs are enabled
          VM_DEPLOYMENT: ${{ github.event.inputs.enable-vms == 'true' && 'true' || 'false' }}
          VM_BRIDGE_IP: ${{ env.VM_BRIDGE_IP }}
          VM_REGISTRY: ${{ env.DEPLOYMENT_REGISTRY }}
          DEPLOYMENT_TARGET: ${{ env.DEPLOYMENT_TARGET }}

      - name: Display Service Information
        run: |
          # Set duration: use input if available (manual run), otherwise 5 minutes (auto run)
          DURATION="${{ github.event.inputs.duration }}"
          if [ -z "$DURATION" ]; then
            DURATION="5"
            TRIGGER_TYPE="Automatic (Push/Schedule)"
          else
            TRIGGER_TYPE="Manual"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Rediacc Elite Services are now running!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "â±ï¸  SELECTED DURATION: ${DURATION} minutes ($TRIGGER_TYPE)"
          echo ""
          
          # Display deployment-specific information
          if [ "${{ github.event.inputs.enable-vms }}" == "true" ]; then
            echo "ğŸ–¥ï¸  DEPLOYMENT: VM Infrastructure"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || 'kvm' }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || 'Basic' }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo "   â€¢ VM Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ“ VM Service URLs:"
            echo "   â€¢ API URL: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
            echo ""
            echo "ğŸ”— SSH Access to Bridge VM:"
            echo "   ssh -i ~/.ssh/vm_key ubuntu@${{ steps.vms.outputs.bridge-ip }}"
          else
            echo "ğŸ³ DEPLOYMENT: GitHub Runner (Docker)"
            echo ""
            echo "ğŸ“ Local Service URLs:"
            echo "   â€¢ API URL: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          fi
          
          echo ""
          echo "â³ Setting up public access via Cloudflare Tunnel..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Save duration for later steps
          echo "$DURATION" > /tmp/duration.txt

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          url: ${{ github.event.inputs.enable-vms == 'true' && format('http://{0}', steps.vms.outputs.bridge-ip) || 'http://localhost' }}
          timeout: 30

      - name: Display Access Information
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ ACCESS INFORMATION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸŒ WEB ACCESS:"
          echo "   â€¢ Cloudflare Tunnel: ${{ steps.tunnel.outputs.tunnel-url }}"
          echo ""

          # Display VM infrastructure details if enabled
          if [ "${{ github.event.inputs.enable-vms }}" == "true" ]; then
            echo "ğŸ–¥ï¸  VM INFRASTRUCTURE:"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || 'kvm' }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || 'Basic' }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo ""
            echo "ğŸ“ VM SERVICE URLS:"
            echo "   â€¢ API: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ” SSH ACCESS TO VMS:"
            echo "   â€¢ Bridge:  ssh ubuntu@${{ steps.vms.outputs.bridge-ip }}"

            # Parse and display worker IPs
            IFS=',' read -ra WORKER_ARRAY <<< "${{ steps.vms.outputs.worker-ips }}"
            for i in "${!WORKER_ARRAY[@]}"; do
              echo "   â€¢ Worker $((i+1)): ssh ubuntu@${WORKER_ARRAY[$i]}"
            done
            echo ""
          else
            echo "ğŸ³ LOCAL SERVICES:"
            echo "   â€¢ API: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
          fi

          echo "ğŸ—„ï¸  DATABASE:"
          echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          echo ""

          # Display debug access if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            echo "ğŸ”§ DEBUG ACCESS (Interactive Terminal):"
            echo "   â€¢ SSH:         ${{ steps.tmate.outputs.ssh-connection }}"
            echo "   â€¢ Web:         ${{ steps.tmate.outputs.web-url }}"
            echo "   â€¢ SSH (RO):    ${{ steps.tmate.outputs.ssh-ro-connection }}"
            echo "   â€¢ Web (RO):    ${{ steps.tmate.outputs.web-ro-url }}"
            echo ""
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Initial Service Status
        run: |
          echo ""
          echo "ğŸ“Š Initial Service Status:"
          ./go status
          echo ""
          echo "âœ… Health Check:"
          ./go health

      - name: Keep Services Alive
        run: |
          # Read duration from saved file
          DURATION_MIN=$(cat /tmp/duration.txt)
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          # Get tunnel URL from action output
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"

          echo ""
          echo "â³ Keeping services alive for ${DURATION_MIN} minutes..."
          echo "   Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "   End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "â±ï¸  Time remaining: ${REMAINING} minutes ($(date '+%H:%M:%S'))"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Run health check
            if ./go health; then
              echo "âœ… All services healthy"
            else
              echo "âš ï¸  Some services may be unhealthy"
              echo ""
              echo "ğŸ“‹ Container Status:"
              ./go status
            fi

            # Display access information
            if [ -n "$TUNNEL_URL" ]; then
              echo ""
              echo "ğŸŒ Public URL: $TUNNEL_URL"
            fi

            # Display debug access if enabled
            if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
              echo "ğŸ”§ Debug SSH: ${{ steps.tmate.outputs.ssh-connection }}"
              echo "ğŸ”§ Debug Web: ${{ steps.tmate.outputs.web-url }}"
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              echo ""
              if [ ${SLEEP_TIME} -eq ${CHECK_INTERVAL} ]; then
                echo "ğŸ’¤ Next health check in $((SLEEP_TIME / 60)) minutes..."
              else
                echo "ğŸ’¤ Final wait: $((SLEEP_TIME / 60)) minute(s) until end of session..."
              fi
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â° Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "ğŸ“Š Final Service Status:"
          ./go status || true
          echo ""
          echo "ğŸ“‹ Recent Logs (last 50 lines):"
          ./go logs --tail=50 || true

      - name: Cleanup Services
        if: always()
        run: |
          echo ""
          echo "ğŸ§¹ Cleaning up services..."

          # Stop tmate session if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ]; then
              if ps -p $TMATE_PID > /dev/null 2>&1; then
                echo "ğŸ–¥ï¸  Stopping tmate session (PID: $TMATE_PID)..."
                kill $TMATE_PID || true
              fi
            fi
          fi

          # Stop cloudflared tunnel
          TUNNEL_PID="${{ steps.tunnel.outputs.tunnel-pid }}"
          if [ -n "$TUNNEL_PID" ]; then
            if ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "ğŸŒ Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
              kill $TUNNEL_PID || true
            fi
          fi

          # Cleanup elite services
          ./action/ci-cleanup.sh
          echo "âœ… Cleanup completed"

      - name: Summary
        if: always()
        run: |
          # Get duration from input (or default to 5 if not set)
          DURATION_MIN="${{ github.event.inputs.duration || '5' }}"

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Run Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "   â€¢ Requested duration: ${DURATION_MIN} minutes"
          echo "   â€¢ Workflow status: ${{ job.status }}"
          echo "   â€¢ Completion time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  cleanup-vms:
    name: Cleanup VM Infrastructure
    needs: [run-services]
    if: always() && github.event.inputs.enable-vms == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout SDK Repository
        uses: actions/checkout@v4
        with:
          repository: rediacc/ops
          ref: main

      - name: Cleanup VMs
        uses: ./sdk/.github/actions/cleanup-vms
        with:
          provider: ${{ github.event.inputs.vm-provider || 'kvm' }}
