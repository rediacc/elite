name: Manual Service Run

# Run services for a specified duration
# - Manual: workflow_dispatch with custom duration
# - Automatic: on push and daily schedule (5 minutes)
on:
  workflow_dispatch:
    inputs:
      duration:
        description: 'Duration to keep services running (minutes)'
        required: true
        default: '30'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
      version:
        description: 'Version for both Docker images and CLI pip package (e.g., latest, v0.1.67, 0.1.67)'
        required: false
        default: 'latest'
        type: string
      enable-debug:
        description: 'Enable tmate SSH debugging session'
        required: false
        default: false
        type: boolean

  push:
    branches:
      - main

  schedule:
    # Run once daily at 00:00 UTC
    - cron: '0 0 * * *'

jobs:
  run-services:
    name: Run Rediacc Elite Services
    runs-on: ubuntu-latest
    timeout-minutes: 180  # 3 hours max

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate and Set Version
        run: |
          VERSION="${{ github.event.inputs.version || 'latest' }}"

          # Validate version format to prevent command injection
          # Allow only: alphanumeric, dots, hyphens, underscores (standard Docker tag format)
          if [[ ! "$VERSION" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            echo "❌ Error: Invalid version format. Only alphanumeric characters, dots, hyphens, and underscores are allowed."
            echo "   Provided: ${VERSION}"
            exit 1
          fi

          # Additional length check (Docker tags max 128 chars)
          if [ ${#VERSION} -gt 128 ]; then
            echo "❌ Error: Version tag too long (max 128 characters)"
            exit 1
          fi

          echo "Selected version: ${VERSION}"

          # Authenticate to GHCR
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # Verify the version exists by checking one of the main images
          if docker manifest inspect "ghcr.io/rediacc/elite/api:${VERSION}" > /dev/null 2>&1; then
            echo "✅ Version ${VERSION} verified in registry"
          else
            echo "⚠️  Warning: Version ${VERSION} not found in registry (continuing anyway)"
          fi

          # Logout immediately after verification
          docker logout ghcr.io

          # Export for subsequent steps (safe after validation)
          echo "TAG=${VERSION}" >> $GITHUB_ENV

      - name: Pre-pull Docker Images
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔐 Pre-pulling Docker images with temporary authentication..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Use a subshell to contain credential exposure
          (
            # Set up environment for image resolution
            export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
            export GITHUB_ACTOR="${{ github.actor }}"
            export TAG="${{ env.TAG }}"

            # Source configuration to get registry and image names
            source action/ci-env.sh
            source .env

            # Authenticate to registry
            echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin

            # Pull all required images
            echo "Pulling nginx:${TAG}..."
            docker pull "${DOCKER_REGISTRY}/nginx:${TAG}"

            echo "Pulling api:${TAG}..."
            docker pull "${DOCKER_REGISTRY}/api:${TAG}"

            echo "Pulling bridge image..."
            docker pull "${DOCKER_BRIDGE_IMAGE}"

            echo "✅ All images pulled successfully"
          )

          # Cleanup credentials completely (outside subshell)
          echo ""
          echo "🧹 Removing all Docker credentials..."
          docker logout ghcr.io
          rm -f ~/.docker/config.json

          # Clear any cached credentials
          unset GITHUB_TOKEN
          unset DOCKER_REGISTRY_PASSWORD

          echo "✅ Credentials cleaned - environment is now safe for debug access"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Create Debug Session
        if: github.event.inputs.enable-debug == 'true'
        id: tmate
        uses: rediacc/action-tmate@v1
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Start Rediacc Elite Services
        id: services
        uses: ./action
        with:
          keep-alive: true  # Don't auto-cleanup, we'll handle it manually
        env:
          TAG: ${{ env.TAG }}

      - name: Display Service Information
        run: |
          # Set duration: use input if available (manual run), otherwise 5 minutes (auto run)
          DURATION="${{ github.event.inputs.duration }}"
          if [ -z "$DURATION" ]; then
            DURATION="5"
            TRIGGER_TYPE="Automatic (Push/Schedule)"
          else
            TRIGGER_TYPE="Manual"
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🚀 Rediacc Elite Services are now running!"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "📦 DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "⏱️  SELECTED DURATION: ${DURATION} minutes ($TRIGGER_TYPE)"
          echo ""
          echo "📍 Local Service URLs:"
          echo "   • API URL: ${{ steps.services.outputs.api-url }}"
          echo "   • Web UI: http://localhost"
          echo ""
          echo "🗄️  Database Connection:"
          echo "   • SQL Server: ${{ steps.services.outputs.sql-connection }}"
          echo ""
          echo "⏳ Setting up public access via Cloudflare Tunnel..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Save duration for later steps
          echo "$DURATION" > /tmp/duration.txt

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          url: http://localhost
          timeout: 30

      - name: Display Access Information
        run: |
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🌍 PUBLIC ACCESS"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "   Cloudflare Tunnel: ${{ steps.tunnel.outputs.tunnel-url }}"
          echo ""

          # Display debug access if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🔧 DEBUG ACCESS (Interactive Terminal)"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "   SSH Terminal:  ${{ steps.tmate.outputs.ssh-connection }}"
            echo "   Web Terminal:  ${{ steps.tmate.outputs.web-url }}"
            echo ""
            echo "   Read-Only SSH: ${{ steps.tmate.outputs.ssh-ro-connection }}"
            echo "   Read-Only Web: ${{ steps.tmate.outputs.web-ro-url }}"
            echo ""
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Initial Service Status
        run: |
          echo ""
          echo "📊 Initial Service Status:"
          ./go status
          echo ""
          echo "✅ Health Check:"
          ./go health

      - name: Keep Services Alive
        run: |
          # Read duration from saved file
          DURATION_MIN=$(cat /tmp/duration.txt)
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          # Get tunnel URL from action output
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"

          echo ""
          echo "⏳ Keeping services alive for ${DURATION_MIN} minutes..."
          echo "   Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "   End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "⏱️  Time remaining: ${REMAINING} minutes ($(date '+%H:%M:%S'))"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            # Run health check
            if ./go health; then
              echo "✅ All services healthy"
            else
              echo "⚠️  Some services may be unhealthy"
              echo ""
              echo "📋 Container Status:"
              ./go status
            fi

            # Display access information
            if [ -n "$TUNNEL_URL" ]; then
              echo ""
              echo "🌍 Public URL: $TUNNEL_URL"
            fi

            # Display debug access if enabled
            if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
              echo "🔧 Debug SSH: ${{ steps.tmate.outputs.ssh-connection }}"
              echo "🔧 Debug Web: ${{ steps.tmate.outputs.web-url }}"
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              echo ""
              if [ ${SLEEP_TIME} -eq ${CHECK_INTERVAL} ]; then
                echo "💤 Next health check in $((SLEEP_TIME / 60)) minutes..."
              else
                echo "💤 Final wait: $((SLEEP_TIME / 60)) minute(s) until end of session..."
              fi
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "⏰ Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "📊 Final Service Status:"
          ./go status || true
          echo ""
          echo "📋 Recent Logs (last 50 lines):"
          ./go logs --tail=50 || true

      - name: Cleanup Services
        if: always()
        run: |
          echo ""
          echo "🧹 Cleaning up services..."

          # Stop tmate session if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ]; then
              if ps -p $TMATE_PID > /dev/null 2>&1; then
                echo "🖥️  Stopping tmate session (PID: $TMATE_PID)..."
                kill $TMATE_PID || true
              fi
            fi
          fi

          # Stop cloudflared tunnel
          TUNNEL_PID="${{ steps.tunnel.outputs.tunnel-pid }}"
          if [ -n "$TUNNEL_PID" ]; then
            if ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "🌐 Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
              kill $TUNNEL_PID || true
            fi
          fi

          # Cleanup elite services
          ./action/ci-cleanup.sh
          echo "✅ Cleanup completed"

      - name: Summary
        if: always()
        run: |
          # Read duration from saved file (fallback to "N/A" if not available)
          DURATION_MIN="N/A"
          if [ -f /tmp/duration.txt ]; then
            DURATION_MIN=$(cat /tmp/duration.txt)
          fi

          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📝 Run Summary"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "   • Requested duration: ${DURATION_MIN} minutes"
          echo "   • Workflow status: ${{ job.status }}"
          echo "   • Completion time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
