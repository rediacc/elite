name: Service Run

run-name: "${{ github.event.inputs.run-name || (github.event_name == 'workflow_dispatch' && 'Manual Service Run') || (github.event_name == 'push' && 'CI Service Run') || (github.event_name == 'pull_request' && format('PR #{0} Service Run', github.event.pull_request.number)) || 'Scheduled Service Run' }}"

# Run services for a specified duration
# - Manual: workflow_dispatch with custom parameters
# - Automatic: on push, pull_request, and daily schedule (uses same defaults as manual)
on:
  workflow_dispatch:
    inputs:
      run-name:
        description: 'Custom name for this run (e.g., "E2E Tests - Login Flow")'
        required: false
        default: 'Manual Service Run'
        type: string
      duration:
        description: 'Duration to keep services running (minutes)'
        required: true
        default: '30'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '300'
      version:
        description: 'Version for Docker images, Python CLI (rediacc), and Node.js CLI (rdc)'
        required: false
        default: 'latest'
        type: string
      enable-vms:
        description: 'Enable VM provisioning for infrastructure testing'
        required: false
        default: true
        type: boolean
      vm-provider:
        description: 'VM infrastructure provider (only if VMs enabled)'
        required: false
        default: 'kvm'
        type: choice
        options:
          - 'kvm'
          - 'linode'
          - 'vultr'
      vm-configuration:
        description: 'VM cluster configuration (only if VMs enabled)'
        required: false
        default: 'Standard'
        type: choice
        options:
          - 'Minimal'
          - 'Basic'
          - 'Standard'
          - 'Full'
      vm-os-image:
        description: 'VM OS image (only if VMs enabled)'
        required: false
        default: 'rediacc-ubuntu-24.04'
        type: choice
        options:
          - 'ubuntu-24.04'
          - 'debian-12'
          - 'debian-11'
          - 'fedora-43'
          - 'fedora-42'
          - 'oracle-linux-9'
          - 'oracle-linux-8'
          - 'opensuse-15.6'
          - 'opensuse-15.5'
          - 'rocky-9'
          - 'centos-stream-10'
          - 'rediacc-ubuntu-24.04'
          - 'rediacc-debian-12'
          - 'rediacc-debian-11'
          - 'rediacc-fedora-43'
          - 'rediacc-oracle-linux-9'
          - 'rediacc-opensuse-15.5'
          - 'rediacc-centos-stream-10'
      enable-debug:
        description: 'Enable tmate SSH debugging session'
        required: false
        default: false
        type: boolean
      skip-machine-registration:
        description: 'Skip automatic machine registration'
        required: false
        default: false
        type: boolean
      ci-mode:
        description: 'Enable CI/TEST mode (bypasses email and captcha validation)'
        required: false
        default: true
        type: boolean
      desktop-environment:
        description: 'Desktop environment for browser access (via noVNC)'
        required: false
        default: 'xfce'
        type: choice
        options:
          - 'none'
          - 'xfce'
          - 'gnome'
          - 'mate'
      desktop-resolution:
        description: 'Desktop screen resolution (only if desktop enabled)'
        required: false
        default: '1600x900'
        type: choice
        options:
          - '1024x768'
          - '1280x720'
          - '1366x768'
          - '1600x900'
          - '1920x1080'
          - '2560x1440'

  push:
    branches:
      - main

  pull_request:
    branches:
      - main

  schedule:
    # Run once daily at 00:00 UTC
    - cron: '0 0 * * *'

jobs:
  run-services:
    name: Run Rediacc Elite Services
    runs-on: ubuntu-latest
    timeout-minutes: 420  # 7 hours max (including VM provisioning time)

    # Consolidated defaults - these match the workflow_dispatch input defaults
    env:
      DEFAULT_DURATION: '30'
      DEFAULT_VM_CONFIGURATION: 'Standard'
      DEFAULT_VM_PROVIDER: 'kvm'
      DEFAULT_VM_OS_IMAGE: 'rediacc-ubuntu-24.04'
      DEFAULT_ENABLE_VMS: 'true'
      DEFAULT_DESKTOP_ENVIRONMENT: 'xfce'
      DEFAULT_DESKTOP_RESOLUTION: '1600x900'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate and Set Version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: ./action/ci-validate-version.sh "${{ github.event.inputs.version || 'latest' }}"

      - name: Pre-pull Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          TAG: ${{ env.TAG }}
          ENABLE_DESKTOP: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'true' || 'false' }}
        run: ./action/ci-pull-images.sh

      - name: Create Debug Session
        if: github.event.inputs.enable-debug == 'true'
        id: tmate
        uses: rediacc/action-tmate@v1
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Start Rediacc Elite Services
        id: services
        uses: ./action
        with:
          keep-alive: true  # Don't auto-cleanup, we'll handle it manually
          ci-mode: ${{ github.event.inputs.ci-mode != 'false' && 'true' || 'false' }}
        env:
          TAG: ${{ env.TAG }}
          # Machine registration will happen later after VMs are provisioned
          SKIP_MACHINE_REGISTRATION: 'true'
          # Enable desktop gateway if requested
          ENABLE_DESKTOP: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'true' || 'false' }}

      - name: Setup Desktop Environment
        if: (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none'
        id: desktop
        env:
          DESKTOP_ENVIRONMENT: ${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}
          DESKTOP_RESOLUTION: ${{ github.event.inputs.desktop-resolution || env.DEFAULT_DESKTOP_RESOLUTION }}
        run: |
          chmod +x action/ci-desktop.sh
          action/ci-desktop.sh

      - name: Extract SSH Keys from Middleware
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        env:
          TAG: ${{ env.TAG }}
          DESKTOP_ENVIRONMENT: ${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”‘ Extracting SSH Keys from Middleware"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Wait for middleware to be fully ready
          echo "Waiting for middleware to be ready..."
          timeout 60 bash -c 'until ./go health; do sleep 2; done'
          echo "âœ“ Middleware is healthy"

          TAG_VERSION="${TAG:-latest}"
          LOCAL_NPM="http://localhost/npm/"

          # Check if CLI packages are embedded in the web image
          echo "Checking for embedded CLI packages..."
          if ! curl -sf "http://localhost/cli-packages.json" > /dev/null 2>&1; then
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ERROR: CLI packages not embedded in web image"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "The web Docker image does not have CLI packages embedded."
            echo "This happens when the image was built without first building"
            echo "the npm package."
            echo ""
            echo "To fix, rebuild the images with:"
            echo "  ./go build npm     # Build Node.js CLI package"
            echo "  ./go build prod    # Build Docker images (embeds CLI packages)"
            echo ""
            echo "Then push the updated images to the registry."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            exit 1
          fi

          # Install rdc CLI (Node.js) - use "latest" URL for simplicity
          # Note: npm package must be embedded in web image via ./go build prod
          echo "Installing rdc CLI (Node.js)..."
          LOCAL_TGZ_LATEST="${LOCAL_NPM}rediacc-cli-latest.tgz"

          if curl -sf "$LOCAL_TGZ_LATEST" -o /dev/null 2>/dev/null; then
            echo "Installing from: $LOCAL_TGZ_LATEST"
            if npm install -g "$LOCAL_TGZ_LATEST"; then
              echo "âœ“ Installed rdc from local /npm/"
            else
              echo "ERROR: Failed to install rdc from local /npm/"
              echo "npm install error shown above ^^^"
              exit 1
            fi
          else
            echo "ERROR: npm package not found at $LOCAL_TGZ_LATEST"
            echo "  The web image may not have npm packages embedded."
            echo "  Rebuild with: ./go build npm && ./go build prod"
            exit 1
          fi

          # Show CLI packages metadata if available
          echo ""
          echo "CLI packages info:"
          curl -sf "http://localhost/cli-packages.json" | jq -r '"  Node.js: \(.packages.nodejs.version) (\(.packages.nodejs.filename))"' 2>/dev/null || echo "  Node.js: (metadata not available)"
          curl -sf "http://localhost/cli-packages.json" | jq -r '"  Renet:   \(.packages.renet.version)"' 2>/dev/null || echo "  Renet: (metadata not available)"

          # Verify installation
          echo ""
          echo "CLI versions installed:"
          rdc --version 2>/dev/null || echo "  rdc: not installed"
          echo ""

          # Source environment for credentials
          source action/ci-env.sh

          # Set API URL explicitly (services run on localhost)
          export SYSTEM_API_URL="http://localhost/api"

          # Login to middleware (Console CLI syntax)
          echo "Logging in to middleware..."
          echo "API URL: $SYSTEM_API_URL"
          rdc auth login \
            --endpoint "$SYSTEM_API_URL" \
            -e "$SYSTEM_ADMIN_EMAIL" \
            -p "$SYSTEM_ADMIN_PASSWORD"

          # Fetch team vault (Console CLI returns array directly)
          echo "Fetching team vault..."
          TEAM_LIST_OUTPUT=$(rdc team list -o json 2>&1)

          # Extract JSON array from output (skip any status messages)
          TEAM_JSON=$(echo "$TEAM_LIST_OUTPUT" | sed -n '/^\[/,$p')

          if [ -z "$TEAM_JSON" ]; then
            echo "ERROR: Failed to get team list from API"
            echo "Raw output: $TEAM_LIST_OUTPUT"
            exit 1
          fi

          # Get vault content for the target team
          VAULT_CONTENT=$(echo "$TEAM_JSON" | \
            jq -r --arg team "$SYSTEM_DEFAULT_TEAM_NAME" \
            '.[] | select(.teamName == $team or .TeamName == $team) | (.vaultContent // .VaultContent // empty)')

          if [ -z "$VAULT_CONTENT" ] || [ "$VAULT_CONTENT" = "null" ]; then
            echo "ERROR: Team vault is empty or not accessible for team '$SYSTEM_DEFAULT_TEAM_NAME'"
            echo "Available teams:"
            echo "$TEAM_JSON" | jq -r '.[].teamName // .[].TeamName'
            exit 1
          fi

          # Parse vault content (handle both string and object formats)
          TEAM_VAULT=$(echo "$VAULT_CONTENT" | jq 'if type == "string" then fromjson else . end' 2>/dev/null)

          if [ -z "$TEAM_VAULT" ] || [ "$TEAM_VAULT" = "null" ] || [ "$TEAM_VAULT" = "{}" ]; then
            echo "ERROR: Failed to parse team vault content"
            echo "Raw vault content: $VAULT_CONTENT"
            exit 1
          fi

          # Extract and decode SSH keys with validation
          echo "Extracting SSH keys from vault..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          SSH_PRIVATE_KEY=$(echo "$TEAM_VAULT" | jq -r '.SSH_PRIVATE_KEY // empty')
          SSH_PUBLIC_KEY=$(echo "$TEAM_VAULT" | jq -r '.SSH_PUBLIC_KEY // empty')

          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "ERROR: SSH_PRIVATE_KEY not found in team vault"
            echo "Vault keys: $(echo "$TEAM_VAULT" | jq -r 'keys | join(", ")')"
            exit 1
          fi

          if [ -z "$SSH_PUBLIC_KEY" ]; then
            echo "ERROR: SSH_PUBLIC_KEY not found in team vault"
            echo "Vault keys: $(echo "$TEAM_VAULT" | jq -r 'keys | join(", ")')"
            exit 1
          fi

          # Decode and write SSH keys
          echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
          echo "$SSH_PUBLIC_KEY" | base64 -d > ~/.ssh/id_rsa.pub

          chmod 600 ~/.ssh/id_rsa
          chmod 644 ~/.ssh/id_rsa.pub

          # Validate the generated files
          if [ ! -s ~/.ssh/id_rsa ]; then
            echo "ERROR: Private key file is empty after decoding"
            exit 1
          fi

          if [ ! -s ~/.ssh/id_rsa.pub ]; then
            echo "ERROR: Public key file is empty after decoding"
            exit 1
          fi

          echo "âœ“ SSH keys extracted and written to ~/.ssh/"
          echo "Key fingerprint:"
          ssh-keygen -lf ~/.ssh/id_rsa.pub

          # Logout
          rdc auth logout

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Provision VMs
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        id: vms
        uses: rediacc/ops/.github/actions/setup-vms@main
        with:
          provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}
          configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}
          duration: ${{ github.event.inputs.duration || env.DEFAULT_DURATION }}
          api-token: ${{ github.event.inputs.vm-provider == 'linode' && secrets.LINODE_API_TOKEN || github.event.inputs.vm-provider == 'vultr' && secrets.VULTR_API_TOKEN || '' }}
        env:
          VM_OS_IMAGE: ${{ github.event.inputs.vm-os-image || env.DEFAULT_VM_OS_IMAGE }}
          TAG: ${{ env.TAG }}
          # DOCKER_REGISTRY is managed by setup-vms action based on provider
          # KVM uses local registry (192.168.111.1:5000), cloud providers use ghcr.io
          DOCKER_BRIDGE_IMAGE: ghcr.io/rediacc/elite/bridge:${{ env.TAG }}
          DOCKER_BRIDGE_NETWORK_MODE: host
          DOCKER_BRIDGE_API_URL: http://localhost
          SYSTEM_API_URL: http://localhost/api
          SKIP_MACHINE_REGISTRATION: 'true'
          CI_MODE: ${{ github.event.inputs.ci-mode != 'false' && 'true' || 'false' }}

      - name: Capture VM Provisioning Logs on Failure
        if: failure() && (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Capturing VM Provisioning Logs (Failure Debug)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # OPS_REPO_PATH is set by setup-vms action
          OPS_PATH="${OPS_REPO_PATH:-/home/runner/work/_actions/rediacc/ops/main}"
          cd "$OPS_PATH" || exit 0

          export OPS_HOME="$(pwd)"
          source scripts/init.sh 2>/dev/null || true

          # Create staging directory for logs
          mkdir -p staging

          # Bridge VM IP (from previous provisioning attempt)
          BRIDGE_IP="192.168.111.1"

          echo ""
          echo "ğŸ” Attempting to retrieve logs from Bridge VM ($BRIDGE_IP)..."
          echo ""

          # Try to copy logs from bridge VM
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes runner@$BRIDGE_IP "test -f /tmp/rediacc_log.txt" 2>/dev/null; then
            echo "ğŸ“„ Bridge Log File (/tmp/rediacc_log.txt):"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "cat /tmp/rediacc_log.txt" 2>/dev/null | tee staging/rediacc_log.txt || true
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo ""
          else
            echo "âš ï¸  Could not access bridge log file"
          fi

          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes runner@$BRIDGE_IP "test -f /tmp/rediacc_err.txt" 2>/dev/null; then
            echo "ğŸ“„ Bridge Error File (/tmp/rediacc_err.txt):"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "cat /tmp/rediacc_err.txt" 2>/dev/null | tee staging/rediacc_err.txt || true
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo ""
          else
            echo "âš ï¸  Could not access bridge error file"
          fi

          # Also try to get docker logs from the bridge VM
          echo "ğŸ“„ Recent Docker Container Logs on Bridge:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "docker ps -a --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}' 2>/dev/null" || true
          echo ""
          ssh -o StrictHostKeyChecking=no runner@$BRIDGE_IP "docker logs \$(docker ps -aq -n 1) 2>&1 | tail -100" 2>/dev/null | tee staging/docker_last_container.txt || true
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

          # Check if local staging files exist from orch_copy_back_files
          if [ -f "$OPS_HOME/staging/rediacc_log.txt" ]; then
            echo "ğŸ“„ Local Staging Log (already copied):"
            cat "$OPS_HOME/staging/rediacc_log.txt"
          fi

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Upload VM Provisioning Logs Artifact
        if: always() && (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: vm-provisioning-logs-${{ github.run_id }}
          path: |
            /home/runner/work/_actions/rediacc/ops/main/staging/
            staging/
          if-no-files-found: ignore
          retention-days: 7

      - name: Display VM Information
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ–¥ï¸  VM Infrastructure Provisioned"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ VM CONFIGURATION:"
          echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
          echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
          echo "   â€¢ OS Image: ${{ github.event.inputs.vm-os-image || env.DEFAULT_VM_OS_IMAGE }}"
          echo "   â€¢ Status: ${{ steps.vms.outputs.status }}"
          echo ""
          echo "ğŸŒ VM ACCESS:"
          echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
          echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
          echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
          echo ""
          echo "ğŸ”‘ SSH KEYS: Using keys from middleware (single source of truth)"
          echo "âš™ï¸  VMs are now accessible with middleware's SSH keys"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Register Worker Machines
        if: (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true' && github.event.inputs.skip-machine-registration != 'true'
        run: |
          source action/ci-env.sh

          # Set environment variables for registration
          export VM_DEPLOYMENT="true"
          export VM_BRIDGE_IP="${{ steps.vms.outputs.bridge-ip }}"
          export VM_WORKER_IPS="${{ steps.vms.outputs.worker-ips }}"
          export VM_PROVIDER="${{ github.event.inputs.vm-provider || 'kvm' }}"

          echo "Registering worker machines with middleware..."
          action/ci-register-workers.sh

      - name: Display Service Information
        run: |
          # Set duration: use input if available, otherwise use consolidated default
          DURATION="${{ github.event.inputs.duration || env.DEFAULT_DURATION }}"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TRIGGER_TYPE="Manual"
          elif [ "${{ github.event_name }}" == "push" ]; then
            TRIGGER_TYPE="Automatic (Push)"
          else
            TRIGGER_TYPE="Automatic (Schedule)"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Rediacc Elite Services are now running!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "â±ï¸  SELECTED DURATION: ${DURATION} minutes ($TRIGGER_TYPE)"
          echo ""
          
          # Display deployment-specific information
          if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then
            echo "ğŸ–¥ï¸  DEPLOYMENT: VM Infrastructure"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo "   â€¢ VM Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ“ VM Service URLs:"
            echo "   â€¢ API URL: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
            echo ""
            echo "ğŸ”— SSH Access to Bridge VM:"
            echo "   ssh -i ~/.ssh/vm_key ubuntu@${{ steps.vms.outputs.bridge-ip }}"
          else
            echo "ğŸ³ DEPLOYMENT: GitHub Runner (Docker)"
            echo ""
            echo "ğŸ“ Local Service URLs:"
            echo "   â€¢ API URL: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
            echo "ğŸ—„ï¸  Database Connection:"
            echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          fi
          
          echo ""
          echo "â³ Setting up public access via Cloudflare Tunnel..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Save duration for later steps
          echo "$DURATION" > /tmp/duration.txt

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          # Elite services always run on localhost (runner or local machine)
          # VMs are separate infrastructure resources for testing, not service deployment targets
          # When desktop is enabled, route through Caddy gateway on port 8080
          url: ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' && 'http://localhost:8080' || 'http://localhost' }}
          timeout: 30

      - name: Initial Service Status
        run: |
          echo ""
          echo "ğŸ“Š Initial Service Status:"
          ./go status
          echo ""
          echo "âœ… Health Check:"
          ./go health

      - name: Export Deployment Information
        run: |
          # Create comprehensive deployment info JSON
          cat > deployment-info.json << EOF
          {
            "metadata": {
              "run_id": "${{ github.run_id }}",
              "duration_minutes": ${{ github.event.inputs.duration || env.DEFAULT_DURATION }},
              "version": "${{ env.TAG }}",
              "triggered_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "workflow_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            },
            "access": {
              "tunnel_url": "${{ steps.tunnel.outputs.tunnel-url }}",
              "api_url": "${{ steps.services.outputs.api-url }}",
              "web_url": "http://localhost",
              "desktop_url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"${{ steps.tunnel.outputs.tunnel-url }}/desktop\""; else echo "null"; fi)
            },
            "database": {
              "connection_string": "Server=sql,1433;Database=RediaccMiddleware;User Id=rediacc;TrustServerCertificate=True"
            },
            "vms": {
              "enabled": ${{ (github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS) == 'true' }},
              "provider": "${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}",
              "configuration": "${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}",
              "bridge_ip": "${{ steps.vms.outputs.bridge-ip || null }}",
              "worker_ips": $(echo '${{ steps.vms.outputs.worker-ips }}' | jq -R 'if . == "" then null else split(",") end'),
              "registry_url": "${{ steps.vms.outputs.registry-url || null }}",
              "machine_user": "${{ steps.vms.outputs.machine-user || null }}",
              "machine_password": "${{ steps.vms.outputs.machine-password || null }}",
              "ssh_access": {
                "bridge": $(if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then echo "\"ssh ${{ steps.vms.outputs.machine-user }}@${{ steps.vms.outputs.bridge-ip }}\""; else echo "null"; fi),
                "workers": $(if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then echo '${{ steps.vms.outputs.worker-ips }}' | jq -R --arg user "${{ steps.vms.outputs.machine-user }}" 'if . == "" then null else split(",") | map("ssh " + $user + "@" + .) end'; else echo "null"; fi)
              }
            },
            "debug": {
              "enabled": ${{ github.event.inputs.enable-debug == 'true' }},
              "ssh_connection": "${{ steps.tmate.outputs.ssh-connection || null }}",
              "web_url": "${{ steps.tmate.outputs.web-url || null }}",
              "ssh_ro_connection": "${{ steps.tmate.outputs.ssh-ro-connection || null }}",
              "web_ro_url": "${{ steps.tmate.outputs.web-ro-url || null }}"
            },
            "desktop": {
              "enabled": ${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) != 'none' }},
              "environment": "${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}",
              "url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"${{ steps.tunnel.outputs.tunnel-url }}/desktop\""; else echo "null"; fi),
              "local_url": $(if [ "${{ (github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT) }}" != "none" ]; then echo "\"http://localhost:6080/vnc.html\""; else echo "null"; fi)
            }
          }
          EOF

          # Beautify JSON with 2-space indentation
          jq --indent 2 '.' deployment-info.json > deployment-info.json.tmp && mv deployment-info.json.tmp deployment-info.json

          # Display for logs
          echo "ğŸ“‹ Deployment Information:"
          cat deployment-info.json

      - name: Upload Deployment Info Artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info-${{ github.run_id }}
          path: deployment-info.json
          retention-days: 1

      - name: Display Access Information and Keep Services Alive
        run: |
          # Display Access Information
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ ACCESS INFORMATION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸŒ WEB ACCESS:"
          echo "   â€¢ Cloudflare Tunnel: ${{ steps.tunnel.outputs.tunnel-url }}"
          DESKTOP_ENV="${{ github.event.inputs.desktop-environment || env.DEFAULT_DESKTOP_ENVIRONMENT }}"
          if [ "$DESKTOP_ENV" != "none" ]; then
            echo "   â€¢ Desktop (noVNC): ${{ steps.tunnel.outputs.tunnel-url }}/desktop"
            echo "   â€¢ Environment: $DESKTOP_ENV"
            echo "   â€¢ Resolution: ${{ github.event.inputs.desktop-resolution || env.DEFAULT_DESKTOP_RESOLUTION }}"
          fi
          echo ""

          # Display VM infrastructure details if enabled
          if [ "${{ github.event.inputs.enable-vms || env.DEFAULT_ENABLE_VMS }}" == "true" ]; then
            echo "ğŸ–¥ï¸  VM INFRASTRUCTURE:"
            echo "   â€¢ Provider: ${{ github.event.inputs.vm-provider || env.DEFAULT_VM_PROVIDER }}"
            echo "   â€¢ Configuration: ${{ github.event.inputs.vm-configuration || env.DEFAULT_VM_CONFIGURATION }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo ""
            echo "ğŸ“ VM SERVICE URLS:"
            echo "   â€¢ API: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Registry: ${{ steps.vms.outputs.registry-url }}"
            echo ""
            echo "ğŸ” VM CREDENTIALS:"
            echo "   â€¢ Username: ${{ steps.vms.outputs.machine-user }}"
            echo "   â€¢ Password: ${{ steps.vms.outputs.machine-password }}"
            echo ""
            echo "ğŸ”‘ SSH ACCESS TO VMS:"
            echo "   â€¢ Bridge:  ssh ${{ steps.vms.outputs.machine-user }}@${{ steps.vms.outputs.bridge-ip }}"

            # Parse and display worker IPs
            IFS=',' read -ra WORKER_ARRAY <<< "${{ steps.vms.outputs.worker-ips }}"
            for i in "${!WORKER_ARRAY[@]}"; do
              echo "   â€¢ Worker $((i+1)): ssh ${{ steps.vms.outputs.machine-user }}@${WORKER_ARRAY[$i]}"
            done
            echo ""
          else
            echo "ğŸ³ LOCAL SERVICES:"
            echo "   â€¢ API: ${{ steps.services.outputs.api-url }}"
            echo "   â€¢ Web UI: http://localhost"
            echo ""
          fi

          echo "ğŸ—„ï¸  DATABASE:"
          echo "   â€¢ SQL Server: ${{ steps.services.outputs.sql-connection }}"
          echo ""

          # Display debug access if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            echo "ğŸ”§ DEBUG ACCESS (Interactive Terminal):"
            echo "   â€¢ SSH:         ${{ steps.tmate.outputs.ssh-connection }}"
            echo "   â€¢ Web:         ${{ steps.tmate.outputs.web-url }}"
            echo "   â€¢ SSH (RO):    ${{ steps.tmate.outputs.ssh-ro-connection }}"
            echo "   â€¢ Web (RO):    ${{ steps.tmate.outputs.web-ro-url }}"
            echo ""
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Keep Services Alive
          DURATION_MIN=$(cat /tmp/duration.txt)
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          echo "â³ Keeping services alive for ${DURATION_MIN} minutes..."
          echo "   Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "   End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            # Run health check quietly
            if ./go health > /dev/null 2>&1; then
              echo "â±ï¸  ${REMAINING} minutes remaining - services healthy"
            else
              echo "â±ï¸  ${REMAINING} minutes remaining - âš ï¸  health check failed"
              echo ""
              echo "ğŸ“‹ Container Status:"
              ./go status
              echo ""
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â° Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "ğŸ“Š Final Service Status:"
          ./go status || true
          echo ""
          echo "ğŸ“‹ Recent Logs (last 50 lines):"
          ./go logs --tail=50 || true

      - name: Cleanup Services
        if: always()
        run: |
          echo ""
          echo "ğŸ§¹ Cleaning up services..."

          # Stop tmate session if enabled
          if [ "${{ github.event.inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ]; then
              if ps -p $TMATE_PID > /dev/null 2>&1; then
                echo "ğŸ–¥ï¸  Stopping tmate session (PID: $TMATE_PID)..."
                kill $TMATE_PID || true
              fi
            fi
          fi

          # Stop cloudflared tunnel
          TUNNEL_PID="${{ steps.tunnel.outputs.tunnel-pid }}"
          if [ -n "$TUNNEL_PID" ]; then
            if ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "ğŸŒ Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
              kill $TUNNEL_PID || true
            fi
          fi

          # Cleanup elite services
          ./action/ci-cleanup.sh
          echo "âœ… Cleanup completed"

      - name: Summary
        if: always()
        run: |
          # Get duration from input or use consolidated default
          DURATION_MIN="${{ github.event.inputs.duration || env.DEFAULT_DURATION }}"

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Run Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "   â€¢ Requested duration: ${DURATION_MIN} minutes"
          echo "   â€¢ Workflow status: ${{ job.status }}"
          echo "   â€¢ Completion time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
